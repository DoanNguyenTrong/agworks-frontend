
// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://sdbnesladhtgunpryzzd.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InNkYm5lc2xhZGh0Z3VucHJ5enpkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDM1NTg1MDIsImV4cCI6MjA1OTEzNDUwMn0.1II3BRsOeMWy_s4wlXqfQhh_9BWD4xmHu4JgoIImR94";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY, {
  auth: {
    persistSession: true,
    autoRefreshToken: true,
    storage: localStorage
  }
});

// Create localStorage helper functions to use as fallback
// These are temporary until the Supabase database is properly set up
export const localStorageApi = {
  getItem: (key: string) => {
    try {
      const item = localStorage.getItem(key);
      return item ? JSON.parse(item) : null;
    } catch (error) {
      console.error(`Error getting ${key} from localStorage:`, error);
      return null;
    }
  },
  setItem: (key: string, value: any) => {
    try {
      localStorage.setItem(key, JSON.stringify(value));
    } catch (error) {
      console.error(`Error setting ${key} in localStorage:`, error);
    }
  },
  removeItem: (key: string) => {
    try {
      localStorage.removeItem(key);
    } catch (error) {
      console.error(`Error removing ${key} from localStorage:`, error);
    }
  }
};

// Helper for working with the profiles table
export const profilesApi = {
  getProfile: async (userId: string) => {
    const { data, error } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', userId)
      .single();
    
    if (error) {
      console.error("Error fetching profile:", error);
      return null;
    }
    
    return data;
  },
  
  updateProfile: async (userId: string, updates: Partial<{
    name: string;
    email: string;
    role: string;
    profile_image: string | null;
    address: string | null;
    phone: string | null;
    logo: string | null;
    company_name: string | null;
  }>) => {
    const { data, error } = await supabase
      .from('profiles')
      .update(updates)
      .eq('id', userId)
      .select();
    
    if (error) {
      console.error("Error updating profile:", error);
      throw error;
    }
    
    return data;
  }
};

// Helper for sites data
export const sitesApi = {
  getSites: async (customerId?: string) => {
    let query = supabase.from('sites').select('*');
    
    if (customerId) {
      query = query.eq('customer_id', customerId);
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error("Error fetching sites:", error);
      return [];
    }
    
    return data;
  },
  
  getSiteById: async (siteId: string) => {
    const { data, error } = await supabase
      .from('sites')
      .select('*')
      .eq('id', siteId)
      .single();
    
    if (error) {
      console.error("Error fetching site:", error);
      return null;
    }
    
    return data;
  },
  
  createSite: async (siteData: {
    name: string;
    address: string;
    customer_id: string;
    manager_id?: string;
  }) => {
    const { data, error } = await supabase
      .from('sites')
      .insert(siteData)
      .select();
    
    if (error) {
      console.error("Error creating site:", error);
      throw error;
    }
    
    return data[0];
  },
  
  updateSite: async (siteId: string, updates: Partial<{
    name: string;
    address: string;
    manager_id: string | null;
  }>) => {
    const { data, error } = await supabase
      .from('sites')
      .update(updates)
      .eq('id', siteId)
      .select();
    
    if (error) {
      console.error("Error updating site:", error);
      throw error;
    }
    
    return data[0];
  },
  
  deleteSite: async (siteId: string) => {
    const { error } = await supabase
      .from('sites')
      .delete()
      .eq('id', siteId);
    
    if (error) {
      console.error("Error deleting site:", error);
      throw error;
    }
    
    return true;
  }
};

// Helper for blocks data
export const blocksApi = {
  getBlocks: async (siteId?: string) => {
    let query = supabase.from('blocks').select('*');
    
    if (siteId) {
      query = query.eq('site_id', siteId);
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error("Error fetching blocks:", error);
      return [];
    }
    
    return data;
  },
  
  getBlockById: async (blockId: string) => {
    const { data, error } = await supabase
      .from('blocks')
      .select('*')
      .eq('id', blockId)
      .single();
    
    if (error) {
      console.error("Error fetching block:", error);
      return null;
    }
    
    return data;
  },
  
  createBlock: async (blockData: {
    name: string;
    site_id: string;
    acres?: number;
    rows?: number;
    vines?: number;
  }) => {
    const { data, error } = await supabase
      .from('blocks')
      .insert(blockData)
      .select();
    
    if (error) {
      console.error("Error creating block:", error);
      throw error;
    }
    
    return data[0];
  },
  
  updateBlock: async (blockId: string, updates: Partial<{
    name: string;
    acres: number | null;
    rows: number | null;
    vines: number | null;
  }>) => {
    const { data, error } = await supabase
      .from('blocks')
      .update(updates)
      .eq('id', blockId)
      .select();
    
    if (error) {
      console.error("Error updating block:", error);
      throw error;
    }
    
    return data[0];
  },
  
  deleteBlock: async (blockId: string) => {
    const { error } = await supabase
      .from('blocks')
      .delete()
      .eq('id', blockId);
    
    if (error) {
      console.error("Error deleting block:", error);
      throw error;
    }
    
    return true;
  }
};

// Helper for work orders data
export const workOrdersApi = {
  getWorkOrders: async (filters?: {
    siteId?: string;
    blockId?: string;
    status?: string;
    createdBy?: string;
  }) => {
    let query = supabase.from('work_orders').select('*');
    
    if (filters?.siteId) {
      query = query.eq('site_id', filters.siteId);
    }
    
    if (filters?.blockId) {
      query = query.eq('block_id', filters.blockId);
    }
    
    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    
    if (filters?.createdBy) {
      query = query.eq('created_by', filters.createdBy);
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error("Error fetching work orders:", error);
      return [];
    }
    
    return data;
  },
  
  getWorkOrderById: async (orderId: string) => {
    const { data, error } = await supabase
      .from('work_orders')
      .select('*')
      .eq('id', orderId)
      .single();
    
    if (error) {
      console.error("Error fetching work order:", error);
      return null;
    }
    
    return data;
  },
  
  createWorkOrder: async (orderData: {
    site_id: string;
    block_id: string;
    address: string;
    start_date: string;
    end_date: string;
    work_type: string;
    needed_workers: number;
    expected_hours: number;
    pay_rate: number;
    created_by: string;
    status: string;
    acres?: number;
    rows?: number;
    vines?: number;
    vines_per_row?: number;
    notes?: string;
  }) => {
    const { data, error } = await supabase
      .from('work_orders')
      .insert(orderData)
      .select();
    
    if (error) {
      console.error("Error creating work order:", error);
      throw error;
    }
    
    return data[0];
  },
  
  updateWorkOrder: async (orderId: string, updates: Partial<{
    start_date: string;
    end_date: string;
    needed_workers: number;
    status: string;
    notes: string | null;
  }>) => {
    const { data, error } = await supabase
      .from('work_orders')
      .update(updates)
      .eq('id', orderId)
      .select();
    
    if (error) {
      console.error("Error updating work order:", error);
      throw error;
    }
    
    return data[0];
  },
  
  deleteWorkOrder: async (orderId: string) => {
    const { error } = await supabase
      .from('work_orders')
      .delete()
      .eq('id', orderId);
    
    if (error) {
      console.error("Error deleting work order:", error);
      throw error;
    }
    
    return true;
  }
};

// Helper for worker applications data
export const workerApplicationsApi = {
  getApplications: async (filters?: {
    workerId?: string;
    orderId?: string;
    status?: string;
  }) => {
    let query = supabase.from('worker_applications').select('*');
    
    if (filters?.workerId) {
      query = query.eq('worker_id', filters.workerId);
    }
    
    if (filters?.orderId) {
      query = query.eq('order_id', filters.orderId);
    }
    
    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error("Error fetching worker applications:", error);
      return [];
    }
    
    return data;
  },
  
  createApplication: async (applicationData: {
    worker_id: string;
    order_id: string;
    status: string;
  }) => {
    const { data, error } = await supabase
      .from('worker_applications')
      .insert(applicationData)
      .select();
    
    if (error) {
      console.error("Error creating worker application:", error);
      throw error;
    }
    
    return data[0];
  },
  
  updateApplicationStatus: async (applicationId: string, status: string) => {
    const { data, error } = await supabase
      .from('worker_applications')
      .update({ status })
      .eq('id', applicationId)
      .select();
    
    if (error) {
      console.error("Error updating worker application status:", error);
      throw error;
    }
    
    return data[0];
  },
  
  deleteApplication: async (applicationId: string) => {
    const { error } = await supabase
      .from('worker_applications')
      .delete()
      .eq('id', applicationId);
    
    if (error) {
      console.error("Error deleting worker application:", error);
      throw error;
    }
    
    return true;
  }
};

// Helper for worker tasks data
export const workerTasksApi = {
  getTasks: async (filters?: {
    workerId?: string;
    orderId?: string;
    status?: string;
  }) => {
    let query = supabase.from('worker_tasks').select('*');
    
    if (filters?.workerId) {
      query = query.eq('worker_id', filters.workerId);
    }
    
    if (filters?.orderId) {
      query = query.eq('order_id', filters.orderId);
    }
    
    if (filters?.status) {
      query = query.eq('status', filters.status);
    }
    
    const { data, error } = await query;
    
    if (error) {
      console.error("Error fetching worker tasks:", error);
      return [];
    }
    
    return data;
  },
  
  getTaskById: async (taskId: string) => {
    const { data, error } = await supabase
      .from('worker_tasks')
      .select('*')
      .eq('id', taskId)
      .single();
    
    if (error) {
      console.error("Error fetching worker task:", error);
      return null;
    }
    
    return data;
  },
  
  createTask: async (taskData: {
    worker_id: string;
    order_id: string;
    status: string;
    photo_url?: string;
    photo_urls?: string[];
  }) => {
    const { data, error } = await supabase
      .from('worker_tasks')
      .insert(taskData)
      .select();
    
    if (error) {
      console.error("Error creating worker task:", error);
      throw error;
    }
    
    return data[0];
  },
  
  updateTask: async (taskId: string, updates: Partial<{
    status: string;
    photo_url: string | null;
    photo_urls: string[] | null;
  }>) => {
    const { data, error } = await supabase
      .from('worker_tasks')
      .update(updates)
      .eq('id', taskId)
      .select();
    
    if (error) {
      console.error("Error updating worker task:", error);
      throw error;
    }
    
    return data[0];
  },
  
  deleteTask: async (taskId: string) => {
    const { error } = await supabase
      .from('worker_tasks')
      .delete()
      .eq('id', taskId);
    
    if (error) {
      console.error("Error deleting worker task:", error);
      throw error;
    }
    
    return true;
  }
};
